#### 来自浏览器的输入事件
  从浏览器的角度看，输入是指用户执行的任何手势，包括文本框输入、鼠标滚动、触摸等等。

  事件类型和坐标由 *浏览器进程* 发送到 *渲染进程*，渲染进程查找事件目标m
  因为浏览器进程是最先收到手势的进程，不过浏览器进程只知道发生的位置，标签页中的内容是由 *渲染进程* 处理的。

#### 设置不可快速滚动的区域
  合成器线程会将绑定了监听器的页面标记为非快速滚动区域，合成器线程确保在输入事件发生时将输入事件发送到主线程。*如果输入事件来自此区域之外，则合成器线程会继续合成新帧，而不会等待主线程。*

  > Web 开发中常见的事件处理模式是事件委托。利用事件冒泡，在最顶层的元素附加一个事件处理程序，而后根据事件目标委派任务，通常很具有吸引力。但从浏览器的角度查看此代码，就会发现整个页面现在会被标记为非快速滚动区域。这意味着，即使应用不关注页面某些部分的输入，合成器线程也必须与主线程通信，并**在每次有输入事件传入时等待**。

> 检查事件是否可取消：`if (event.cancelable) {}`

####
当合成器线程向主线程发送输入事件时，首先要运行的是查找事件目标的命中测试。点击测试会使用在渲染过程中生成的绘制记录数据，找出事件发生点坐标下方的内容。


Chrome会合并连续的事件（例如 wheel、mousewheel、mousemove、pointermove、touchmove），并将调度延迟到下一个 `requestAnimationFrame` 之前。

但如果要根据 `touchmove` 坐标设置路径等，为了绘制平滑线条，可能会丢失两者之间的坐标。在这种情况下，您可以在指针事件中使用` getCoalescedEvents()` 方法来获取有关这些合并事件的信息。

  