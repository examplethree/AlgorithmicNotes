# Leetcode刷题笔记

## 单调栈

## 贪心

## 二分法
 * 222.Count Complete Tree Nodes(10.26)  位运算，二分法（解法启发对mid值上下取整的思考）  mid取上整可用 `mid = (l+r+1)/2` 或 `mid = l + (r-l+1)/2` ，取下整则为 `mid = (l+r)/2` 或 `mid = l + (r-l)/2` 。默认 `/` 符号表示向下取整，JS中使用取整函数。
   
 * 74.Search a 2D Matrix(10.27)
 >*二分法取整出现死循环问题（该问题出现于while的进入条件为 `while(l<r)` ，即不取等号；取等号的写法能避免上下取整导致的死循环问题）*  `low=mid`（即if的判断条件是 `mid>target` ）mid应该向上取整；`high=mid`（即判断条件 `mid<target` ）应该向下取整。
 > 另一种while循环的写法可以避开对mid的上下取整问题，如下。但是对于LC74这样的问题，目标值不会出现，而是要找到所有小于target的最大数，则使用 `while(l<r)` 比较直观方便，退出循环时 `l===r` ，此时 `l` 指向的就是要找的值，或者这个数不存在，指向边界。
 ```
    while(l<=r){
        if(nums[mid] < target){
            l = mid+1;
        }
        else if(nums[mid] > target){
            r = mid-1;
        }
        else{
            return mid;
        }
    }
    //或有重复元素时，查找第一个出现（或最后一个出现）的目标元素
    while(l<=r){
        if(nums[mid] < target){
            l = mid+1;
        }
        else if(nums[mid] >= target){
            r = mid-1;//第一个出现
        }
    }
 ```

 * 240.Search a 2D Matrix II（10.28）  
   二维查找问题的二分法。  确定一个完全有序的部分，选定可以在这个部分查找，或排除一个部分的判定条件。

 * 81.搜索旋转排序数组II (10.30)  
   首先遍历部分数组找到中断点的方法时间复杂度O(n)，已经不属于二分查找的可能  
   *本题正确二分法的思路是：找到局部完全有序的部分，因为在完全有序的局部判断是否能存在target是容易的，所以可以有着一点写分支，缩小查找范围。*  
   需要注意的是，这一判断条件需要足够充分，并且注意重复元素造成的影响

 * 33.搜索旋转排序数组 (10.31)  
   将 `nums[l]===nums[mid]` 的情况单独写出，更便于理解，因为 `nums[mid]` 和 `target` 比较过了，所以如果有一样的值直接跳过就可以，故 `l++`

## DFS 和 BFS
 是否需要使用visited辅助数组的问题，访问过的元素如何标记，才能更方便于整个任务的完成
 * 130.被围绕的区域（11.03）
   区分开被围绕的区域和没有被围绕的区域，本题从边界出发作为切入点可以省去很多麻烦
 * 200.岛屿数量（11.04）

## 拓扑排序和图
 * 207.课程表
 只用 *入度数组* 记录入度的变化即可实现“前驱已完成”的效果，而不需要建立前驱数组，对其中的元素进行删改
 * 208.课程表Ⅱ
 类似上题，返回拓扑排序数组，只需要每次出队后再保存即可。