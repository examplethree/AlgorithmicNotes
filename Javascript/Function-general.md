# 函数一般
 一个特殊情况是，将命名函数赋值给一个变量。
 ```
    var foo = function bar() {
        bar(); // 正常运行
    }
    bar(); // 出错：ReferenceError
 ```
  `bar` 函数声明外是不可见的，这是因为我们已经把函数赋值给了 `foo`； 然而在 `bar` 内部依然可见。这是由于 JavaScript 的 *命名处理* 所致，函数名在函数内 *总是* 可见的。

# 作用域与命名空间
 尽管 JavaScript 支持一对花括号创建的代码段，但是并**不支持块级作用域**；而仅仅支持函数作用域。
 >不支持块级作用域的表现就是变量声明会**提升到函数或全局作用域**，导致在块内部声明的变量在块外部也可见
  
 JavaScript 中没有**显式**的命名空间定义，这就意味着所有对象都定义在一个全局共享的命名空间下面。
 > 但可以用对象字面量和匿名函数等方式来模拟简单的命名空间。全局共享命名空间可以避免命名冲突和不必要的全局变量。

## 隐式的全局变量
 不使用 var 声明变量将会导致隐式的全局变量产生
 ```
    // 全局作用域
    var foo = 42;
    function test() {
        // 局部作用域
        foo = 21;
    }
    test();
    foo; // 21
 ```
 在函数 `test` 内不使用 `var` 关键字声明 `foo` 变量将会覆盖外部的同名变量。 起初这看起来并不是大问题，但是当有成千上万行代码时，不使用 `var` 声明变量将会带来难以跟踪的BUG。

 另一个局部变量的定义
 ```
    // 全局变量
    var foo = 1;
    var bar = 2;
    var i = 2;

    function test(i) {
        // 函数 test 内的局部作用域
        i = 5;

        var foo = 3;
        bar = 4;
    }
    test(10);
 ```
 `foo` 和 `i` 是函数 `test` 内的局部变量，而对 `bar` 的赋值将会覆盖全局作用域内的同名变量。
 注意**形参中声明**的局部变量

 关于块级作用域和变量声明提升，理解下列代码：
 ```
    // 译者注：来自 Nettuts+ 的一段代码，生动的阐述了 JavaScript 中变量声明提升规则
    var myvar = 'my value';  
    
    (function() {  
        alert(myvar); // undefined  
        var myvar = 'local value';  
    })();  
 ```
 ### 名称解析顺序
  JavaScript 中的所有作用域，包括全局作用域，都有一个特别的名称 `this` 指向当前对象。  
  函数作用域内也有默认的变量 `arguments`，其中包含了传递到函数中的参数。  
  比如，当访问函数内的 `foo` 变量时，JavaScript 会按照下面顺序查找：

   1. 当前作用域内是否有 `var foo` 的定义。
   2. 函数形式参数是否有使用 `foo` 名称的。
   3. **函数自身**是否叫做 `foo`。
   4. 回溯到上一级作用域，然后从 #1 重新开始。
 >注意: 自定义 `arguments` 参数将会阻止原生的 `arguments` 对象的创建

 ### 命名空间

 只有一个全局作用域导致的常见错误是命名冲突。在 JavaScript中，这可以通过 *匿名包装器* 轻松解决。
 ```
    (function() {
        // 函数创建一个命名空间

        window.foo = function() {
            // 对外公开的函数，创建了闭包
        };
    })(); // 立即执行此匿名函数
 ```
 匿名函数被认为是 表达式；因此为了可调用性，它们首先会被执行。

( // 小括号内的函数首先被执行
function() {}
) // 并且返回函数对象
() // 调用上面的执行结果，也就是函数对象
有一些其他的调用函数表达式的方法，比如下面的两种方式语法不同，但是效果一模一样。

// 另外两种方式
+function(){}();
(function(){}());